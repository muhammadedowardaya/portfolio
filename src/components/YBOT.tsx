/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {
	createContext,
	useContext,
	useEffect,
	useMemo,
	useRef,
	useState,
} from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import {
	LoopOnce,
	LoopRepeat,
	MathUtils,
	Vector3,
	type AnimationAction,
	type Group,
	type SkinnedMesh,
} from 'three';
import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import {
	characterActionAtom,
	characterModeAtom,
	characterPositionAtom,
	currentIntroIndexAtom,
	directionAtom,
	isLookingAtom,
	leftHandPositionAtom,
	rightHandPositionAtom,
	selectedMenuAtom,
} from '@/lib/jotai';
import { CuboidCollider, RigidBody } from '@react-three/rapier';
import { useFrame, useThree } from '@react-three/fiber';
import type { JSX } from 'astro/jsx-runtime';
import type { Object3D } from 'three';
import useWindowSize from '@/hooks/useWindowSize';

type CharacterProps = JSX.IntrinsicElements['group'] & {
	loopAnimation?: Boolean;
};

export function YBOT({ loopAnimation, ...props }: CharacterProps) {
	const group = useRef<Group>(null);
	const { nodes, materials, animations } = useGLTF(
		`${import.meta.env.BASE_URL}/models/YBOT.glb`
	);
	const { actions, mixer } = useAnimations(animations, group);

	const { camera } = useThree();

	const lastSelectedMenuRef = useRef<string | null>(null);
	const lastCharacterActionRef = useRef<string | null>(null);

	const direction = useAtomValue(directionAtom);

	const [zoomType, setZoomType] = useState<1 | 2 | 0>(0);

	const { width } = useWindowSize();

	const [characterPosition, setCharacterPosition] = useAtom(
		characterPositionAtom
	);

	const audioRef = useRef<
		Record<'walking' | 'running' | 'wind', HTMLAudioElement>
	>({
		walking: new Audio(`${import.meta.env.BASE_URL}/sfx/robot-step.mp3`),
		running: new Audio(`${import.meta.env.BASE_URL}/sfx/running.mp3`),
		wind: new Audio(`${import.meta.env.BASE_URL}/sfx/wind.mp3`),
	});

	const setLeftHandPosition = useSetAtom(leftHandPositionAtom);
	const setRightHandPosition = useSetAtom(rightHandPositionAtom);

	const [currentIntroIndex, setCurrentIntroIndex] = useAtom(
		currentIntroIndexAtom
	);
	const characterMode = useAtomValue(characterModeAtom);

	const isLooking = useAtomValue(isLookingAtom);

	const selectedMenu = useAtomValue(selectedMenuAtom);
	const [characterAction, setCharacterAction] = useAtom(characterActionAtom);

	const [currentAction, setCurrentAction] = useState<AnimationAction | null>(
		null
	);

	const loopableActions = useMemo(
		() => [
			'idle',
			'walking',
			'running',
			'floating',
			'carrying',
			'neutral_idle',
			'sitting_idle',
			'offensive_idle',
			'flying',
		],
		[]
	);

	const rigidbodyRef = useRef<any>(null);

	const leftHandRef = useRef<Object3D>(null!);
	const rightHandRef = useRef<Object3D>(null!);

	const [movementForContactMenu, setMovementForContactMenu] = useState(false);
	const [standToSitting, setStandToSitting] = useState(false);

	function delay(ms: number) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}

	useEffect(() => {
		async function handleLooking() {
			setCharacterAction('looking');
			setZoomType(1);
			await delay(4000);
			setZoomType(2);
		}

		function playSFX(mode: 'walking' | 'running' | 'wind' | null) {
			// Stop all sounds first

			Object.values(audioRef.current).forEach((audio) => {
				audio.pause();
				audio.currentTime = 0;
				audio.loop = true;

				if (mode === 'walking') {
					audioRef.current.walking.play();
					audio.playbackRate = 3.2;
				} else if (mode === 'running') {
					audioRef.current.walking.play();
					audio.playbackRate = 5.1;
				} else if (mode === 'wind') {
					audioRef.current.wind.play();
					audio.playbackRate = 1;
				}
			});
		}

		function fadeOutAudio(audio: HTMLAudioElement, duration = 1000) {
			const stepTime = 50; // Interval in ms
			const steps = duration / stepTime;
			const volumeStep = audio.volume / steps;

			const interval = setInterval(() => {
				if (audio.volume - volumeStep > 0) {
					audio.volume -= volumeStep;
				} else {
					audio.volume = 0;
					audio.pause();
					audio.currentTime = 0;
					clearInterval(interval);
				}
			}, stepTime);
		}

		if (isLooking) {
			handleLooking();
		} else {
			if (direction === null) {
				if (characterMode === 'flying') {
					setCharacterAction('floating');
				} else if (characterMode === 'running') {
					setCharacterAction('offensive_idle');
				} else {
					setCharacterAction('idle');
				}

				playSFX(null);
			} else if (characterMode === 'walking') {
				setCharacterAction('walking');
				playSFX('walking');
			} else if (characterMode === 'running') {
				setCharacterAction('running');
				playSFX('running');
			} else if (characterMode === 'flying') {
				setCharacterAction('flying');
				playSFX('wind');
			}
		}
	}, [direction, characterMode, isLooking]);

	useEffect(() => {
		if (selectedMenu === 'tentang_saya') {
			if (lastSelectedMenuRef.current === 'kontak') {
				setMovementForContactMenu(true);

				audioRef.current.walking.currentTime = 0;
				audioRef.current.walking.loop = true;
				audioRef.current.walking.playbackRate = 3.2;

				setCharacterAction('sit_to_stand');

				setTimeout(() => {
					setStandToSitting(false);
					setCharacterAction('walking');
				}, 1000);

				setTimeout(() => {
					audioRef.current.walking.play();
				}, 1800);

				setTimeout(() => {
					audioRef.current.walking.pause();
				}, 2800);
			}

			setTimeout(
				() => {
					if (currentIntroIndex === 1) {
						setCharacterAction('standing_greeting');
					} else if (currentIntroIndex === 2) {
						setCharacterAction('wave_hip_hop_dance');
					} else if (currentIntroIndex === 3) {
						setCharacterAction('carrying');
					}
					setMovementForContactMenu(false);
				},
				lastSelectedMenuRef.current === 'kontak' ? 2000 : 0
			);
		} else if (selectedMenu === 'telusuri_jalan_ini') {
			setCurrentIntroIndex(1);

			if (lastSelectedMenuRef.current === 'kontak') {
				setMovementForContactMenu(true);

				audioRef.current.walking.currentTime = 0;
				audioRef.current.walking.loop = true;
				audioRef.current.walking.playbackRate = 3.2;

				setCharacterAction('sit_to_stand');

				setTimeout(() => {
					setStandToSitting(false);
					setCharacterAction('walking');
				}, 1000);

				setTimeout(() => {
					audioRef.current.walking.play();
				}, 1800);

				setTimeout(() => {
					audioRef.current.walking.pause();
				}, 2800);
			}

			setTimeout(
				() => {
					setCharacterAction('idle');
					setMovementForContactMenu(false);
					audioRef.current.walking.pause();
				},
				lastSelectedMenuRef.current === 'kontak' ? 2000 : 0
			);
		} else if (selectedMenu === 'kontak') {
			setCurrentIntroIndex(1);
			setCharacterAction('sitting');
			setMovementForContactMenu(true);
			audioRef.current.walking.currentTime = 0;
			audioRef.current.walking.loop = true;
			audioRef.current.walking.playbackRate = 3.2;

			setTimeout(() => {
				audioRef.current.walking.play();
			}, 1000);

			setTimeout(() => {
				audioRef.current.walking.pause();
			}, 3400);

			setTimeout(() => {
				setStandToSitting(true);
			}, 800);
		}

		lastSelectedMenuRef.current = selectedMenu;
	}, [selectedMenu, currentIntroIndex]);

	const handleCameraFollow = () => {
		// Kamera mengikuti karakter
		const pos = rigidbodyRef.current.translation();

		if (selectedMenu === 'tentang_saya') {
			let offset = new Vector3(0, 3, 5);

			if (currentIntroIndex === 3) {
				offset = new Vector3(0, 3, 2);
			}

			const targetPosition = new Vector3(pos.x, pos.y, -4).add(offset);
			camera.position.lerp(targetPosition, 0.1);
			// camera.lookAt(pos.x, pos.y, pos.z);
		} else if (selectedMenu === 'telusuri_jalan_ini') {
			let offset = new Vector3(0, 3, 7);

			if (isLooking && width >= 1024) {
				if (zoomType === 1) {
					offset = new Vector3(1.28, 3.2, 0.35);
				} else if (zoomType === 2) {
					offset = new Vector3(1.78, 3.2, 1.4);
				}
			} else if (isLooking && width >= 600) {
				if (zoomType === 1) {
					offset = new Vector3(0.5, 3.2, 0.4);
				} else if (zoomType === 2) {
					offset = new Vector3(1, 3.2, 1.45);
				}
			} else if (isLooking) {
				if (zoomType === 1) {
					offset = new Vector3(0.3, 3.2, 0.4);
				} else if (zoomType === 2) {
					offset = new Vector3(0.7, 3.2, 1.45);
				}
			}

			const targetPosition = new Vector3(pos.x, pos.y, -4).add(offset);
			camera.position.lerp(
				targetPosition,
				isLooking ? (width >= 1024 ? 0.1 : 0.05) : 0.2
			);
			// camera.lookAt(pos.x, pos.y, pos.z);
		} else if (selectedMenu === 'kontak') {
			const offset = new Vector3(0, 3, 5);
			const targetPosition = new Vector3(pos.x, pos.y, pos.z).add(offset);
			camera.position.lerp(targetPosition, 0.1);
			// camera.lookAt(pos.x, pos.y, pos.z);
		}
	};

	const handleCharacterRotation = () => {
		let targetY = 0;

		if (direction === 'right') targetY = Math.PI / 2;
		else if (direction === 'left') targetY = -Math.PI / 2;
		else if (selectedMenu === 'kontak') targetY = -Math.PI;
		else if (lastSelectedMenuRef.current === 'kontak') targetY = Math.PI;
		else if (isLooking) targetY = Math.PI;

		if (group.current) {
			group.current.rotation.y = MathUtils.lerp(
				group.current.rotation.y,
				targetY,
				lastSelectedMenuRef.current === 'kontak' && selectedMenu !== 'kontak'
					? 1
					: 0.3
			);
		}
	};

	const handleCharacterMovement = () => {
		if (!rigidbodyRef.current) return;

		const translation = rigidbodyRef.current.translation();
		setCharacterPosition([translation.x, translation.y, translation.z]);

		if (movementForContactMenu) {
			const currentZ = Math.floor(translation.z * 10) / 10;

			// console.info(currentZ);

			const backLimit = -7;
			const frontLimit = -4;
			// const speedStep = standToSitting ? -1 : 1.9; // atur sehalus yang kamu mau

			if (standToSitting) {
				// mundur
				if (currentZ > backLimit) {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: -1.5 }, true);
				} else {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: 0 }, true);
				}
			} else {
				// maju kembali
				if (currentZ < frontLimit) {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: 1.9 }, true);
				} else {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: 0 }, true);
				}
			}
		}

		if (selectedMenu === 'telusuri_jalan_ini') {
			const speed =
				characterAction === 'walking'
					? 1.9
					: characterAction === 'running'
					? 5
					: 7;

			let vel;

			// Realtime batas kiri dan kanan
			const maxLeft = translation.x < -158;
			const maxRight = translation.x > 168;

			if (direction === 'right') {
				vel = speed;
				rigidbodyRef.current.setLinvel({ x: vel, y: 0, z: 0 }, true);

				if (!maxRight) {
					rigidbodyRef.current.setLinvel({ x: vel, y: 0, z: 0 }, true);
				} else {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: 0 }, true);
				}
			} else if (direction === 'left') {
				vel = -speed;
				rigidbodyRef.current.setLinvel({ x: vel, y: 0, z: 0 }, true);

				if (!maxLeft) {
					rigidbodyRef.current.setLinvel({ x: vel, y: 0, z: 0 }, true);
				} else {
					rigidbodyRef.current.setLinvel({ x: 0, y: 0, z: 0 }, true);
				}
			}
		}
	};

	useFrame(() => {
		if (!rigidbodyRef.current) return;

		handleCharacterRotation();
		handleCharacterMovement();
		handleCameraFollow();

		// dapatkan posisi tangan dari karakter
		if (leftHandRef.current) {
			const worldPos = new Vector3();
			leftHandRef.current.getWorldPosition(worldPos);
			setLeftHandPosition([worldPos.x, worldPos.y, worldPos.z]);
		}

		if (rightHandRef.current) {
			const worldPos = new Vector3();
			rightHandRef.current.getWorldPosition(worldPos);
			setRightHandPosition([worldPos.x, worldPos.y, worldPos.z]);
		}
	});

	useEffect(() => {
		if (!actions || !mixer) return;

		let action = actions[characterAction];
		if (!action) return;

		let fadeDuration = 0.5;

		if (characterAction === 'carrying') {
			fadeDuration = 1;
		} else if (
			lastCharacterActionRef.current === 'sitting_idle' &&
			characterAction === 'sit_to_stand'
		) {
			fadeDuration = 1;
		} else if (characterAction === 'sitting_idle') {
			fadeDuration = 1;
		} else if (
			characterAction === 'neutral_idle' ||
			lastCharacterActionRef.current === 'looking'
		) {
			fadeDuration = 1;
		}

		const onFinished = () => {
			mixer.removeEventListener('finished', onFinished);
			if (characterAction === 'sitting') {
				setCharacterAction('sitting_idle'); // atau nextAction, tergantung antrian animasi kamu
			} else if (characterAction === 'looking') {
				setCharacterAction('neutral_idle');
			} else {
				setCharacterAction('idle');
			}
		};

		currentAction?.fadeOut(fadeDuration);
		action.reset().fadeIn(fadeDuration).play();

		if (loopableActions.includes(characterAction)) {
			action.loop = LoopRepeat;
			action.clampWhenFinished = false;
		} else {
			action.loop = LoopOnce;
			action.clampWhenFinished = true;
			mixer.addEventListener('finished', onFinished);
		}

		lastCharacterActionRef.current = characterAction;
		setCurrentAction(action);
	}, [actions, mixer, currentAction, characterAction]);

	useEffect(() => {
		if (nodes.mixamorigLeftHand && nodes.mixamorigRightHand) {
			leftHandRef.current = nodes.mixamorigLeftHand;
			rightHandRef.current = nodes.mixamorigRightHand;
		}
	}, [nodes]);

	return (
		<RigidBody
			ref={rigidbodyRef}
			type="dynamic"
			colliders={false}
			gravityScale={1}
			position={[-145, 4, -4]}
			rotation={[0, 0, 0]}
			lockRotations
			canSleep={false}
			linearDamping={3}
			enabledTranslations={
				selectedMenu === 'telusuri_jalan_ini' && !movementForContactMenu
					? [true, true, false]
					: [true, true, true]
			}
		>
			<CuboidCollider
				args={[0.5 /*half-width*/, 1 /*half-height*/, 0.3 /*half-depth*/]}
				position={[0, 1, 0]}
			/>
			<mesh ref={group} {...props}>
				<group name="Scene">
					<group
						name="base"
						rotation={[Math.PI / 2, 0, 0]}
						scale={0.01}
						castShadow
					>
						<skinnedMesh
							name="Alpha_Joints"
							geometry={(nodes.Alpha_Joints as SkinnedMesh).geometry}
							material={materials.Alpha_Joints_MAT}
							skeleton={(nodes.Alpha_Joints as SkinnedMesh).skeleton}
							castShadow
						/>
						<skinnedMesh
							name="Alpha_Surface"
							geometry={(nodes.Alpha_Surface as SkinnedMesh).geometry}
							material={materials.Alpha_Body_MAT}
							skeleton={(nodes.Alpha_Surface as SkinnedMesh).skeleton}
							castShadow
						/>
						<primitive object={nodes.mixamorigHips} />
					</group>
				</group>
			</mesh>
		</RigidBody>
	);
}

useGLTF.preload(`${import.meta.env.BASE_URL}/models/YBOT.glb`);
